import os
import time
import uuid
from datetime import datetime, timedelta
from functools import wraps

from flask import Flask, request, jsonify
from sqlalchemy import create_engine, String, DateTime, Boolean, ForeignKey
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, Session, relationship
from sqlalchemy.exc import IntegrityError
from dotenv import load_dotenv
import bcrypt
import jwt

# -----------------------------
# Config
# -----------------------------
load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")
JWT_SECRET = os.getenv("JWT_SECRET", "change_me")
ACCESS_TOKEN_TTL = int(os.getenv("ACCESS_TOKEN_TTL", "900"))           # seconds
REFRESH_TOKEN_TTL = int(os.getenv("REFRESH_TOKEN_TTL", "1209600"))     # seconds
APP_NAME = os.getenv("APP_NAME", "SecureAuthAPI")

if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL is required (see .env.example)")
if not JWT_SECRET or JWT_SECRET == "change_me":
    raise RuntimeError("Set a strong JWT_SECRET in .env")

app = Flask(__name__)
app.config["JSON_SORT_KEYS"] = False

# -----------------------------
# Database (SQLAlchemy 2.0)
# -----------------------------
engine = create_engine(DATABASE_URL, echo=False, future=True)

class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = "users"

    id: Mapped[str] = mapped_column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    name: Mapped[str] = mapped_column(String(120))
    password_hash: Mapped[str] = mapped_column(String(200))
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=datetime.utcnow)

    tokens: Mapped[list["TokenBlocklist"]] = relationship(back_populates="user")

class TokenBlocklist(Base):
    """
    Stores revoked/used JWTs (by JTI) for both access and refresh tokens.
    """
    __tablename__ = "token_blocklist"

    id: Mapped[str] = mapped_column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    jti: Mapped[str] = mapped_column(String(36), index=True, unique=True)
    token_type: Mapped[str] = mapped_column(String(10))  # "access" | "refresh"
    user_id: Mapped[str] = mapped_column(String(36), ForeignKey("users.id"))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=datetime.utcnow)

    user: Mapped[User] = relationship(back_populates="tokens")

Base.metadata.create_all(engine)

# -----------------------------
# Helpers: passwords & tokens
# -----------------------------
def hash_password(password: str) -> str:
    salt = bcrypt.gensalt(rounds=12)
    return bcrypt.hashpw(password.encode("utf-8"), salt).decode("utf-8")

def verify_password(password: str, password_hash: str) -> bool:
    try:
        return bcrypt.checkpw(password.encode("utf-8"), password_hash.encode("utf-8"))
    except Exception:
        return False

def _now_ts() -> int:
    return int(time.time())

def _encode_jwt(payload: dict, ttl_seconds: int) -> str:
    iat = _now_ts()
    exp = iat + ttl_seconds
    jti = str(uuid.uuid4())
    body = {
        "iss": APP_NAME,
        "iat": iat,
        "exp": exp,
        "jti": jti,
        **payload,
    }
    return jwt.encode(body, JWT_SECRET, algorithm="HS256")

def _decode_jwt(token: str) -> dict:
    return jwt.decode(token, JWT_SECRET, algorithms=["HS256"], options={"require": ["exp", "iat", "jti"]})

def _is_revoked(session: Session, jti: str) -> bool:
    return session.query(TokenBlocklist).filter_by(jti=jti).first() is not None

def _revoke(session: Session, jti: str, token_type: str, user_id: str) -> None:
    session.add(TokenBlocklist(jti=jti, token_type=token_type, user_id=user_id))
    session.commit()

# -----------------------------
# Decorator: require access JWT
# -----------------------------
def require_access_token(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        auth = request.headers.get("Authorization", "")
        if not auth.startswith("Bearer "):
            return jsonify({"error": "Missing or invalid Authorization header"}), 401
        token = auth.split(" ", 1)[1].strip()
        try:
            payload = _decode_jwt(token)
        except jwt.ExpiredSignatureError:
            return jsonify({"error": "Access token expired"}), 401
        except jwt.InvalidTokenError:
            return jsonify({"error": "Invalid token"}), 401

        if payload.get("type") != "access":
            return jsonify({"error": "Wrong token type"}), 401

        with Session(engine) as s:
            if _is_revoked(s, payload["jti"]):
                return jsonify({"error": "Token revoked"}), 401
            user = s.get(User, payload.get("sub"))
            if not user or not user.is_active:
                return jsonify({"error": "User not found or inactive"}), 401

        request.user_id = payload["sub"]
        request.token_jti = payload["jti"]
        return fn(*args, **kwargs)
    return wrapper

# -----------------------------
# Routes
# -----------------------------
@app.get("/health")
def health():
    return {"status": "ok", "app": APP_NAME, "time": datetime.utcnow().isoformat()}

@app.post("/auth/register")
def register():
    data = request.get_json(force=True, silent=True) or {}
    email = (data.get("email") or "").strip().lower()
    name = (data.get("name") or "").strip()
    password = data.get("password") or ""

    if not email or "@" not in email:
        return jsonify({"error": "Valid email required"}), 400
    if not name or len(name) < 2:
        return jsonify({"error": "Name must be at least 2 chars"}), 400
    if not password or len(password) < 8:
        return jsonify({"error": "Password must be at least 8 chars"}), 400

    with Session(engine) as s:
        user = User(email=email, name=name, password_hash=hash_password(password))
        s.add(user)
        try:
            s.commit()
        except IntegrityError:
            s.rollback()
            return jsonify({"error": "Email already registered"}), 409

    return jsonify({"message": "Registered successfully"}), 201

@app.post("/auth/login")
def login():
    data = request.get_json(force=True, silent=True) or {}
    email = (data.get("email") or "").strip().lower()
    password = data.get("password") or ""

    with Session(engine) as s:
        user = s.query(User).filter_by(email=email).first()
        if not user or not verify_password(password, user.password_hash):
            return jsonify({"error": "Invalid credentials"}), 401

        access = _encode_jwt({"sub": user.id, "type": "access"}, ACCESS_TOKEN_TTL)
        refresh = _encode_jwt({"sub": user.id, "type": "refresh"}, REFRESH_TOKEN_TTL)

        return jsonify({
            "user": {"id": user.id, "email": user.email, "name": user.name},
            "access_token": access,
            "refresh_token": refresh,
            "token_type": "Bearer",
            "expires_in": ACCESS_TOKEN_TTL
        })

@app.post("/auth/refresh")
def refresh():
    """
    Accepts a refresh token, returns a fresh access token.
    Rotates (revokes) the used refresh token and issues a new one (optional but safer).
    """
    data = request.get_json(force=True, silent=True) or {}
    token = data.get("refresh_token") or ""

    try:
        payload = _decode_jwt(token)
        if payload.get("type") != "refresh":
            return jsonify({"error": "Wrong token type"}), 401
    except jwt.ExpiredSignatureError:
        return jsonify({"error": "Refresh token expired"}), 401
    except jwt.InvalidTokenError:
        return jsonify({"error": "Invalid token"}), 401

    user_id = payload.get("sub")
    jti = payload.get("jti")

    with Session(engine) as s:
        if _is_revoked(s, jti):
            return jsonify({"error": "Refresh token already used/revoked"}), 401
        user = s.get(User, user_id)
        if not user or not user.is_active:
            return jsonify({"error": "User not found or inactive"}), 401

        # revoke old refresh token (rotation)
        _revoke(s, jti, "refresh", user_id)

        # issue new tokens
        new_access = _encode_jwt({"sub": user.id, "type": "access"}, ACCESS_TOKEN_TTL)
        new_refresh = _encode_jwt({"sub": user.id, "type": "refresh"}, REFRESH_TOKEN_TTL)

    return jsonify({"access_token": new_access, "refresh_token": new_refresh, "token_type": "Bearer", "expires_in": ACCESS_TOKEN_TTL})

@app.post("/auth/logout")
@require_access_token
def logout():
    """
    Revokes the current access token (server-side logout).
    """
    with Session(engine) as s:
        _revoke(s, request.token_jti, "access", request.user_id)
    return jsonify({"message": "Logged out"})

@app.get("/auth/me")
@require_access_token
def me():
    with Session(engine) as s:
        user = s.get(User, request.user_id)
        return jsonify({"id": user.id, "email": user.email, "name": user.name, "created_at": user.created_at.isoformat()})

# Example protected resource
@app.get("/notes")
@require_access_token
def list_notes():
    # placeholder protected resource
    return jsonify({"notes": [
        {"id": 1, "title": "Welcome", "owner": request.user_id},
        {"id": 2, "title": "This route is protected by JWT", "owner": request.user_id}
    ]})

# -----------------------------
# Entrypoint
# -----------------------------
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000, debug=True)
